#!/usr/bin/env python3


import argparse
import sys

import numpy as np
import numexpr as ne


def phi_generator(column):
    phi = []

    for l in sys.stdin:
        s = l.split()
        if not s or s[0][0] == '#':
            if phi:
                yield np.array(phi, dtype=np.float64)
                phi.clear()
        else:
            phi.append(s[column])

    if phi:
        yield np.array(phi, dtype=np.float64)


def Q_cumulant(n, phi):
    return ne.evaluate('sum(exp(1j*n*phi))')


def cumulant_generator(the_n, k_max, Q, M):
    for n in the_n:
        # v_n{2}
        Qn = Q[n]
        Qnsq = ne.evaluate('real(Qn*conj(Qn))')
        corr2_numerator = ne.evaluate('sum(Qnsq - M)')
        corr2_denominator = ne.evaluate('sum(M*(M-1))')
        corr2 = corr2_numerator / corr2_denominator
        cn2 = corr2
        vn2 = abs(cn2)**.5
        if cn2 < 0:
            vn2 *= -1
        yield vn2

        if k_max == 2:
            continue

        # v_n{4}
        Q2n = Q[2*n]
        corr4_numerator = ne.evaluate(
            '''sum(
               Qnsq*Qnsq + real(Q2n*conj(Q2n))
               - 2*real(Q2n*conj(Qn)*conj(Qn))
               - 4*(M-2)*Qnsq + 2*M*(M-3)
            )'''
        )
        corr4_denominator = ne.evaluate('sum(M*(M-1)*(M-2)*(M-3))')
        corr4 = corr4_numerator / corr4_denominator
        cn4 = corr4 - 2.*corr2*corr2
        vn4 = abs(cn4)**.25
        if cn4 > 0:
            vn4 *= -1
        yield vn4


def main():
    parser = argparse.ArgumentParser(
        description='''Calculate flow cumulants v_n{k}.  Reads phi (azimuthal
        angles) from stdin.  No particle filtering is done (e.g. charged
        particles, pT cut).  Any line that is blank or starts with a comment
        (#) is an event separator.  Outputs cumulants in the order
        v2{2}, v2{4}, ..., v3{2}, v3{4}, ...''',
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )

    parser.add_argument('-c', '--column',
                        type=int, default=2,
                        help='Column number containing phi values, \
                        counted from 0.'
                        )
    parser.add_argument('-n', '--max-vn',
                        type=int, choices=range(2, 10), default=4,
                        metavar='(2-9)',
                        help='Maximum flow harmonic.'
                        )
    parser.add_argument('-k', '--max-cumulant',
                        type=int, choices=(2, 4), default=2,
                        help='Maximum cumulant.'
                        )

    args = parser.parse_args()

    the_n = range(2, args.max_vn+1)
    the_k = range(2, args.max_cumulant+1, 2)

    Qn_to_calculate = frozenset(n*int(k/2) for n in the_n for k in the_k)

    # initialize containers to hold multiplicity and Q_n vectors
    M = []
    Q = {n: [] for n in Qn_to_calculate}  # using dict as a sparse list

    # loop over events
    # append multiplicity and Q_n to respective lists
    for phi in phi_generator(args.column):
        M.append(phi.size)
        for n, _Qn in Q.items():
            _Qn.append(Q_cumulant(n, phi))

    # convert to numpy arrays
    # store multiplicities as floats, not ints
    # otherwise powers of mult. could overflow
    # anyway, mult. is cast to floating point when calculating cumulants
    M = np.array(M, dtype=np.float64)
    for n, _Qn in Q.items():
        Q[n] = np.array(_Qn, dtype=np.complex128)

    print(*cumulant_generator(the_n, args.max_cumulant, Q, M))


if __name__ == "__main__":
    main()
